{"name":"Stub.by","tagline":"","body":"# Stubby\r\n\r\n```\r\na small web server for stubbing external systems during development\r\n```\r\n\r\n##### Why the word \"stubby\"?\r\nIt is a stub HTTP server after all, hence the \"stubby\". Also, in Australian slang \"stubby\" means _beer bottle_\r\n\r\n## Table of Contents\r\n\r\n* [Versions Available](#versions-available)\r\n* [Installation](#installation)\r\n* [Key Features](#key-features)\r\n* [Why would a developer use stubby](#why-would-a-developer-use-stubby)\r\n* [Why would a QA use stubby](#why-would-a-qa-use-stubby)\r\n* [Command-line Switches](#command-line-switches)\r\n* [Endpoint Configuration HOWTO](#endpoint-configuration)\r\n   * [Request](#request)\r\n   * [Response](#response)\r\n* [The Admin Portal](#the-admin-portal)\r\n* [The Stubs Portal](#the-stubs-portal)\r\n* [Programmatic APIs](#programmatic-apis)\r\n\r\n## Versions Available\r\n\r\n* [Java](http://stub.by/4j)\r\n* [Nodejs](http://stub.by/4node)\r\n* [.NET](http://stub.by/4net)\r\n\r\n## Installation\r\n\r\n### Java\r\n\r\nAvailable on [Maven Central](http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22by.stub%22%20AND%20a%3A%22stubby4j%22)\r\n\r\n* __Group ID__ by.stub\r\n* __Artifact ID__ stubby4j\r\n\r\n### Node\r\n\r\nAs a command-line tool\r\n\r\n```\r\nnpm install -g stubby\r\n```\r\n\r\nor as a module dependency\r\n\r\n```\r\nnpm install stubby\r\n```\r\n\r\n### .NET\r\n\r\nAs a command-line: [.NET Downloads](http://stub.by/downloads/4net)\r\n\r\nor as a project reference via NuGet\r\n\r\n```\r\nPM> Install-Package stubby\r\n```\r\n\r\n## Key Features\r\n* Emulates external webservices in a sandbox for your application to consume over HTTP(S)\r\n* HTTP request verification and HTTP response stubbing\r\n* Regex support for dynamic matching on URI, query params, headers, POST body (ie:. `mod_rewrite` in Apache)\r\n* Dynamic flows: Multiple stubbed responses on the same stubbed URI to test multiple application flows\r\n* Fault injection, where after X good responses on the same URI you get a bad one\r\n* Serve binary files as stubbed response content (images, PDFs. etc.)\r\n* Embed stubby to create a web service sandbox for your integration test suite\r\n\r\n### Incubating features (experimental or not present in all versions)\r\n* Dynamic token replacement in stubbed responses by leveraging regex capturing groups as token values during HTTP request verification\r\n* Record & Replay. The HTTP response is recorded on the first call, having the subsequent calls play back the recorded HTTP response, without actually connecting to the external server\r\n\r\n## Why would a developer use stubby?\r\n#### You want to:\r\n* Simulate responses from real server and don't care to (or cannot) go over the network\r\n* Stub third party web services that your application contacts which are not yet ready\r\n* Verify that your code makes HTTP requests with all the required parameters and/or headers\r\n* Verify that your code correctly handles HTTP error codes\r\n* Trigger a response from the server based on the request parameters over HTTP or HTTPS\r\n* Support any of the available HTTP methods\r\n* Simulate support for Basic Authentication\r\n* Support HTTP 30x redirects\r\n* Provide canned answers in your contract/integration tests\r\n* Enable delayed responses for performance and stability testing\r\n* Avoid to spend time coding for the above requirements\r\n* Concentrate on the task at hand\r\n\r\n## Why would a QA use stubby?\r\n#### You want to:\r\n* Specify mock responses to simulate page conditions without real data\r\n* Test polling mechanisms by stubbing a sequence of responses for the same URI\r\n* Easily swap data config files to run different data sets and responses\r\n* Have an all-in-one stub server to handle mock data with less need to upkeep code for test generation\r\n\r\n## Command-line Switches\r\n```\r\nStandard switches:\r\n -a,--admin <arg>      Port for admin portal. Defaults to 8889.\r\n -d,--data <arg>       Data file to pre-load endoints. YAML or JSON format.\r\n -h,--help             This help text.\r\n -l,--location <arg>   Hostname at which to bind stubby.\r\n -m,--mute             Prevent stubby from printing to the console.\r\n -s,--stubs <arg>      Port for stub portal. Defaults to 8882.\r\n -t,--tls <arg>        Port for https stubs portal. Defaults to 7443.\r\n -w,--watch            Auto-reload data file when edits are made.\r\n -v,--version          Prints stubby's version number.\r\n\r\nstubby4j switches:\r\n -p,--password <arg>   Password for the provided keystore file.\r\n -k,--keystore <arg>   Keystore file for custom SSL. By default SSL is\r\n                       enabled using internal keystore.\r\n\r\nstubby4node switches:\r\n -p,--pfx <arg>        PFX file. Ignored if used with --key/--cert\r\n -k,--key <arg>        Private key file. Use with --cert.\r\n -c,--cert <arg>       Certificate file. Use with --key.\r\n```\r\n\r\n## Endpoint Configuration\r\n\r\nThis section explains the usage, intent and behavior of each property on the `request` and `response` objects.\r\n\r\nHere is a fully-populated, unrealistic endpoint:\r\n```yaml\r\n- request:\r\n    url: ^/your/awesome/endpoint$\r\n    method: POST\r\n    query:\r\n      exclamation: post requests can have query strings!\r\n    headers:\r\n      content-type: application/xml\r\n    post: >\r\n      <!xml blah=\"blah blah blah\">\r\n      <envelope>\r\n        <unaryTag/>\r\n      </envelope>\r\n    file: tryMyFirst.xml\r\n  response:\r\n  - status: 200\r\n    latency: 5000\r\n    headers:\r\n      content-type: application/xml\r\n      server: stubbedServer/4.2\r\n    body: >\r\n      <!xml blah=\"blah blah blah\">\r\n      <responseXML>\r\n        <content></content>\r\n      </responseXML>\r\n    file: responseData.xml\r\n  - status: 200\r\n    body: \"Haha!\"\r\n```\r\n\r\n### request\r\n\r\nThis object is used to match an incoming request to stubby against the available endpoints that have been configured.\r\n\r\n#### url (required)\r\n\r\n* is a full-fledged __regular expression__\r\n* This is the only required property of an endpoint.\r\n* signify the url after the base host and port (i.e. after `localhost:8882`).\r\n* any query paramters are stripped (so don't include them, that's what `query` is for).\r\n    * `/url?some=value&another=value` becomes `/url`\r\n* no checking is done for URI-encoding compliance.\r\n    * If it's invalid, it won't ever trigger a match.\r\n\r\nThis is the simplest you can get:\r\n```yaml\r\n- request:\r\n    url: /\r\n```\r\n\r\nA demonstration using regular expressions:\r\n```yaml\r\n- request:\r\n    url: ^/has/to/begin/with/this/\r\n\r\n- request:\r\n    url: /has/to/end/with/this/$\r\n\r\n- request:\r\n    url: ^/must/be/this/exactly/with/optional/trailing/slash/?$\r\n\r\n- request:\r\n    url: ^/[a-z]{3}-[a-z]{3}/[0-9]{2}/[A-Z]{2}/[a-z0-9]+$\r\n```\r\n\r\n#### method\r\n\r\n* defaults to `GET`.\r\n* case-insensitive.\r\n* can be any of the following:\r\n    * HEAD\r\n    * GET\r\n    * POST\r\n    * PUT\r\n    * POST\r\n    * DELETE\r\n    * etc.\r\n\r\n```yaml\r\n- request:\r\n    url: /anything\r\n    method: GET\r\n```\r\n\r\n* it can also be an array of values.\r\n\r\n```yaml\r\n- request:\r\n    url: /anything\r\n    method: [GET, HEAD]\r\n\r\n- request:\r\n    url: /anything\r\n    method:\r\n      - GET\r\n      - HEAD\r\n      - POST\r\n```\r\n\r\n#### query\r\n\r\n* values are full-fledged __regular expressions__\r\n* if ommitted, stubby ignores query parameters for the given url.\r\n* a yaml hashmap of variable/value pairs.\r\n* allows the query parameters to appear in any order in a uri\r\n\r\n```yaml\r\n-  request:\r\n      method: GET\r\n      url: ^/with/parameters$\r\n      query:\r\n         type_name: user\r\n         client_id: id\r\n         client_secret: secret\r\n         random_id: \"^sequence/-/\\\\d/\"\r\n         session_id: \"^user_\\\\d{32}_local\"\r\n```\r\n\r\n* The following will match either of these:\r\n    * `/with/parameters?search=search+terms&filter=month`\r\n    * `/with/parameters?filter=month&search=search+terms`\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/with/parameters$\r\n      query:\r\n         search: search terms\r\n         filter: month\r\n```\r\n\r\n#### post\r\n\r\n* is a full-fledged __regular expression__\r\n* if ommitted, any post data is ignored.\r\n* represents the body POST of incoming request, ie.: form data\r\n\r\n```yaml\r\n- request:\r\n    url: ^/post/form/data$\r\n    post: name=John&email=john@example.com\r\n```\r\n\r\n```yaml\r\n- request:\r\n    method: [POST]\r\n    url: /uri/with/post/regex\r\n    post: \"^[\\\\.,'a-zA-Z\\\\s+]*$\"\r\n```\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/post/form/data$\r\n      post: \"^this/is/\\\\d/post/body\"\r\n```\r\n\r\n#### file\r\n\r\n* holds a path to a local file (absolute or relative to the YAML specified in `-d` or `--data`)\r\n* if supplied, replaces `post` with the contents from the provided file\r\n    * paths are relative from where the `--data` file is located\r\n* if the local file could not be loaded for whatever reason (ie.: not found), stubby falls back to `post` for matching.\r\n* allows you to split up stubby data across multiple files instead of making one huge bloated main YAML\r\n\r\n```yaml\r\n-  request:\r\n      url: ^/match/against/file$\r\n      file: postedData.json\r\n      post: '{\"fallback\":\"data\"}'\r\n```\r\n\r\npostedData.json\r\n```json\r\n{\"fileContents\":\"match against this if the file is here\"}\r\n```\r\n\r\n* if `postedData.json` doesn't exist on the filesystem when `/match/against/file` is matched in incoming request, stubby will match post contents against `{\"fallback\":\"data\"}` (from `post`) instead.\r\n\r\n#### headers\r\n\r\n* values are full-fledged __regular expressions__\r\n* a hashmap of header/value pairs similar to `query`.\r\n* if ommitted, stubby ignores headers for the given url\r\n* if stubbed, stubby will try to match __only__ the supplied headers and will ignore other headers of incoming request. In other words, the incoming request __must__ contain stubbed header values\r\n* headers are case-insensitive during matching\r\n\r\nThe following endpoint only accepts requests with `application/json` post values:\r\n\r\n```yaml\r\n-  request:\r\n      url: /post/json\r\n      method: post\r\n      headers:\r\n         content-type: application/json\r\n         x-custom-header: \"^this/is/\\d/test\"\r\n         x-custom-header-2: \"^[a-z]{4}_\\\\d{32}_(local|remote)\"\r\n```\r\n\r\n### response\r\n\r\nAssuming a match has been made against the given `request` object, data from `response` is used to build the stubbed response back to the client.\r\n\r\n* Can be a single response or a sequence of responses\r\n* When sequenced responses are configured, upon each incoming request to the same URI a subsequent response in the list will be sent to the client. The sequenced responses play in a cycle \r\n\r\n```yaml\r\n- request:\r\n    method: [GET,POST]\r\n    url: /invoice/123\r\n\r\n  response:\r\n    status: 201\r\n    headers:\r\n      content-type: application/json\r\n    body: OK\r\n\r\n\r\n- request:\r\n    method: [GET]\r\n    url: /uri/with/sequenced/responses\r\n\r\n  response:\r\n  - status: 201\r\n    headers:\r\n      content-type: application/json\r\n    body: OK\r\n\r\n  - status: 201\r\n      headers:\r\n        content-stype: application/json\r\n      body: Still going strong!\r\n\r\n  - status: 500\r\n    headers:\r\n      content-type: application/json\r\n    body: OMG!!!\r\n\r\n\r\n- request:\r\n    method: [GET]\r\n    url: /uri/with/sequenced/responses/infile\r\n\r\n  response:\r\n  - status: 201\r\n    headers:\r\n      content-type: application/json\r\n    file: ../json/sequenced.response.ok.json\r\n\r\n  - status: 201\r\n    headers:\r\n      content-stype: application/json\r\n    file: ../json/sequenced.response.goingstrong.json\r\n\r\n  - status: 500\r\n    headers:\r\n      content-type: application/json\r\n    file: ../json/sequenced.response.omfg.json\r\n\r\n- request:\r\n    method: [GET]\r\n    url: /uri/with/single/sequenced/response\r\n\r\n  response:\r\n  - status: 201\r\n    headers:\r\n      content-stype: application/json\r\n    body: Still going strong!\r\n```\r\n\r\n#### status\r\n\r\n* the HTTP status code of the response.\r\n* integer or integer-like string.\r\n* defaults to `200`.\r\n\r\n```yaml\r\n- request:\r\n    url: ^/im/a/teapot$\r\n    method: POST\r\n  response:\r\n    status: 420\r\n```\r\n\r\n#### body\r\n\r\n* contents of the response body\r\n* defaults to an empty content body\r\n\r\n```yaml\r\n- request:\r\n    url: ^/give/me/a/smile$\r\n  response:\r\n    body: ':)'\r\n```\r\n\r\n```yaml\r\n- request:\r\n    url: ^/give/me/a/smile$\r\n\r\n  response:\r\n    status: 200\r\n    body: >\r\n      {\"status\": \"hello world with single quote\"}\r\n    headers:\r\n      content-type: application/json\r\n```\r\n\r\n```yaml\r\n- request:\r\n    method: GET\r\n    url: /atomfeed/1\r\n\r\n  response:\r\n    headers:\r\n      content-type: application/xml\r\n    status: 200\r\n    body: <?xml version=\"1.0\" encoding=\"UTF-8\"?><payment><paymentDetail><invoiceTypeLookupCode/></paymentDetail></payment>\r\n```\r\n\r\n```yaml\r\n- request:\r\n    url: /1.1/direct_messages.json\r\n    query:\r\n      since_id: 240136858829479935\r\n      count: 1\r\n  response:\r\n    headers:\r\n      content-type: application/json\r\n    body: https://api.twitter.com/1.1/direct_messages.json?since_id=240136858829479935&count=1\r\n```\r\n\r\n#### file\r\n\r\n* similar to `request.file`, but the contents of the file are used as the response `body`\r\n* if the file could not be loaded, stubby falls back to the value stubbed in `body`\r\n* if `body` was not stubbed, an empty string is returned by default\r\n* it can be an ASCII or binary file (PDF, images, etc.)\r\n\r\n```yaml\r\n- request:\r\n    url: /\r\n  response:\r\n    file: extremelyLongJsonFile.json\r\n```\r\n\r\n#### headers\r\n\r\n* similar to `request.headers` except that these are sent back to the client.\r\n* by default, the header `x-stubby-resource-id` containing the admin portal resource ID is returned with each stubbed response. The ID is useful if the returned resource needs to be updated at run time by ID via the admin portal\r\n\r\n```yaml\r\n- request:\r\n    url: ^/give/me/some/json$\r\n  response:\r\n    headers:\r\n      content-type: application/json\r\n    body: >\r\n         [{\r\n            \"name\":\"John\",\r\n            \"email\":\"john@example.com\"\r\n         },{\r\n            \"name\":\"Jane\",\r\n            \"email\":\"jane@example.com\"\r\n         }]\r\n```\r\n\r\n#### latency\r\n\r\n* time to wait, in milliseconds, before sending back the response\r\n* good for testing timeouts, or slow connections\r\n\r\n```yaml\r\n- request:\r\n    url: ^/hello/to/jupiter$\r\n  response:\r\n    latency: 800000\r\n    body: Hello, World!\r\n```\r\n\r\n## The Admin Portal\r\n\r\nThe admin portal is a RESTful(ish) endpoint running on `localhost:8889`. Or wherever you described through stubby's command line args.\r\n\r\n### Supplying Endpoints to Stubby\r\n\r\nSubmit `POST` requests to `localhost:8889` or load a data-file (using -d / --data flags) with the following structure for each endpoint:\r\n\r\n* `request`: describes the client's call to the server\r\n   * `method`: GET/POST/PUT/DELETE/etc.\r\n   * `url`: the URI regex string.\r\n   * `query`: a key/value map of query string parameters included with the request. Query param value can be regex.\r\n   * `headers`: a key/value map of headers the server should respond to. Header value can be regex.\r\n   * `post`: a string matching the textual body of the response. Post value can be regex.\r\n   * `file`: if specified, returns the contents of the given file as the request post. If the file cannot be found at request time, **post** is used instead\r\n* `response`: describes the server's response (or array of responses, refer to the examples) to the client\r\n   * `headers`: a key/value map of headers the server should use in it's response.\r\n   * `latency`: the time in milliseconds the server should wait before responding. Useful for testing timeouts and latency\r\n   * `file`: if specified, returns the contents of the given file as the response body. If the file cannot be found at request time, **body** is used instead\r\n   * `body`: the textual body of the server's response to the client\r\n   * `status`: the numerical HTTP status code (200 for OK, 404 for NOT FOUND, etc.)\r\n\r\n\r\n#### YAML (file only or POST/PUT)\r\n```yaml\r\n- request:\r\n    url: ^/path/to/something$\r\n    method: POST\r\n    headers:\r\n      authorization: \"bob:password\"\r\n      x-custom-header: \"^this/is/\\d/test\"\r\n    post: this is some post data in textual format\r\n  response:\r\n    headers:\r\n      Content-Type: application/json\r\n    latency: 1000\r\n    status: 200\r\n    body: You're request was successfully processed!\r\n\r\n- request:\r\n    url: ^/path/to/anotherThing\r\n    query:\r\n      a: anything\r\n      b: more\r\n      custom: \"^this/is/\\d/test\"\r\n    method: GET\r\n    headers:\r\n      Content-Type: application/json\r\n    post:\r\n  response:\r\n    headers:\r\n      Content-Type: application/json\r\n      Access-Control-Allow-Origin: \"*\"\r\n    status: 204\r\n    file: path/to/page.html\r\n\r\n- request:\r\n    url: ^/path/to/thing$\r\n    method: POST\r\n    headers:\r\n      Content-Type: application/json\r\n    post: this is some post data in textual format\r\n  response:\r\n    headers:\r\n      Content-Type: application/json\r\n    status: 304\r\n```\r\n\r\n\r\n#### JSON (file or POST/PUT)\r\n```json\r\n[\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/something$\",\r\n      \"post\": \"this is some post data in textual format\",\r\n      \"headers\": {\r\n         \"authorization\": \"bob:password\"\r\n      },\r\n      \"method\": \"POST\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 200,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"latency\": 1000,\r\n      \"body\": \"You're request was successfully processed!\"\r\n    }\r\n  },\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/anotherThing\",\r\n      \"query\": {\r\n         \"a\": \"anything\",\r\n         \"b\": \"more\"\r\n      },\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"method\": \"GET\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 204,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\",\r\n        \"Access-Control-Allow-Origin\": \"*\"\r\n      },\r\n      \"file\": \"path/to/page.html\"\r\n    }\r\n  },\r\n  {\r\n    \"request\": {\r\n      \"url\": \"^/path/to/thing$\",\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      },\r\n      \"post\": \"this is some post data in textual format\",\r\n      \"method\": \"POST\"\r\n    },\r\n    \"response\": {\r\n      \"status\": 304,\r\n      \"headers\": {\r\n        \"Content-Type\": \"application/json\"\r\n      }\r\n    }\r\n  }\r\n]\r\n```\r\n\r\nIf you want to load more than one endpoint via file, use either a JSON array or YAML list (-) syntax. When creating or updating one stubbed request, the response will contain `Location` in the header with the newly created resources' location\r\n\r\n### Getting the ID of a Loaded Endpoint\r\n\r\nStubby adds the response-header `x-stubby-resource-id` to outgoing responses. This ID can be referenced for use with the Admin portal.\r\n\r\n### Getting the Current List of Stubbed Endpoints\r\n\r\nPerforming a `GET` request on `localhost:8889` will return a YAML list of all currently saved responses. It will reply with `204 : No Content` if there are none saved.\r\n\r\nPerforming a `GET` request on `localhost:8889/<id>` will return the YAML object representing the response with the supplied id.\r\n\r\n#### The Status Page\r\n\r\nYou can also view the currently configured endpoints by going to `localhost:8889/status`\r\n\r\n#### The Refresh Stubbed Data Endpoint\r\n\r\nIf for some reason you do not want/cannot/not able to use `--watch` flag when starting stubby4j (or cannot restart),\r\nyou can submit `GET` request to `localhost:8889/refresh` (or load it in a browser) in order to refresh the stubbed data.\r\n\r\n### Changing Existing Endpoints\r\n\r\nPerform `PUT` requests in the same format as using `POST`, only this time supply the id in the path. For instance, to update the response with id 4 you would `PUT` to `localhost:8889/4`.\r\n\r\n### Deleting Endpoints\r\n\r\nSend a `DELETE` request to `localhost:8889/<id>`\r\n\r\n## The Stubs Portal\r\n\r\nRequests sent to any url at `localhost:8882` (or wherever you told stubby to run) will search through the available endpoints and, if a match is found, respond with that endpoint's `response` data\r\n\r\n### How Endpoints Are Matched\r\n\r\nFor a given endpoint, stubby only cares about matching the properties of the request that have been defined in the YAML. The exception to this rule is `method`; if it is omitted it is defaulted to `GET`.\r\n\r\nFor instance, the following will match any `POST` request to the root url:\r\n\r\n```yaml\r\n- request:\r\n    url: /\r\n    method: POST\r\n  response: {}\r\n```\r\n\r\nThe request could have any headers and any post body it wants. It will match the above.\r\n\r\nPseudocode:\r\n\r\n```\r\nfor each <endpoint> of stored endpoints {\r\n\r\n   for each <property> of <endpoint> {\r\n      if <endpoint>.<property> != <incoming request>.<property>\r\n         next endpoint\r\n   }\r\n\r\n   return <endpoint>\r\n}\r\n```\r\n\r\n\r\n## Programmatic APIs\r\n\r\nSince programming languages vary, please refer to the individual project pages for their respective programmatic interfaces.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}